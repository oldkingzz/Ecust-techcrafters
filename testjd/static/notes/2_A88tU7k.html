<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>2-intro</title>
  </head>
  
<h1 id="计算理性computational-rationality">2. 计算理性（computational
Rationality)</h1>
<h3 id="理性智能体">1. 理性智能体</h3>
<h5 id="智能体">智能体</h5>
<p>具有自治性、社会性、反应性和预动性的基本特征的实体，也可被看作是相应的软件程序或者是一个实体（比如人、车辆、机器人等）</p>
<h5 id="加个理性">加个理性</h5>
<p>主要作用是acting rationally</p>
<p>理性：能使期待的性能指标最大化</p>
<p>特点：通过动作器（执行器）对外部环境施加作用，还可以通过学习和应用知识来实现目标。</p>
<p>主要包括：</p>
<p>传感器：检测环境变化</p>
<p>执行器：能量转化为运动</p>
<p>效应器：影响环境</p>
<figure>
<img src="https://s1.ax1x.com/2023/08/05/pPkyMPP.png"
alt="1691199927226" />
<figcaption aria-hidden="true">1691199927226</figcaption>
</figure>
<p>特征：</p>
<p>Think like human</p>
<p>Act like human</p>
<p>举个例子：</p>
<p>你和机器人下象棋，如果在你对面的是一个机器人，他需要有人协助把你下的每一步输入给他，那它就只是一个ai工具。但如果这个机器人能通过视力获得你下的位置，能自动进行思考分析下一步的走法，同时还有机器手能移动棋盘上的棋子，那就说明人家是rational
agent</p>
<h3 id="机器学习">机器学习</h3>
<p>机器学习的本质就是一个找复杂函数的能力。</p>
<p>举个例子，假设我们现在已知两个直角坐标系中的两个点，现在我们相求他们之间的距离。常规的做法是，将纵坐标相减，横坐标相减，最后再平方开根号。但如果用机器学习的方法怎么做呢？</p>
<p>很简答，找一万个数据对，这数据对中包含三个信息，分别是第一个点的坐标，第二个点的坐标和他们之间的距离。然后使用机器学习的方法将他们拟合成一个不知道有多复杂的函数。这个时候，你在对这个模型输入两个点的坐标后，它的输出就很接近正确解。</p>
<p>以上是不是很扯？有科学方法为什么要那么复杂。实际上，隔壁物理系的同学经常使用这招来拟合数据，以发现更加直观的结论。同时这个方法可以说是ai的基本方法了，就像大火的chatgpt的前身gpt3，本质上就是这么一个函数，但那个函数的复杂度就比较恐怖了，大约1750亿个参数。</p>
<p>学习图谱：</p>
<figure>
<img src="https://s1.ax1x.com/2023/08/05/pPkyvz8.png"
alt="1691200454425" />
<figcaption aria-hidden="true">1691200454425</figcaption>
</figure>
<h4 id="回归regression">回归（regression）</h4>
<p>回归是统计学中的分析方法，用来研究变量之间的关系和预测。</p>
<p>例如，通过分析体重和身高的回归关系，可以预测某人的体重可能是多少，基于其身高数据。</p>
<p>也就是说，回归就是基于已有数据进行分析训练之后，对未来数据进行准确预测。</p>
<h4 id="分类classification">分类（classification）</h4>
<p>分类是一种数据分析方法，将事物划分到不同的类别或组别中，根据其特征和属性进行归类。</p>
<p>两种常用分类</p>
<h5 id="二元分类">二元分类</h5>
<p>顾名思义，就是分类只有两类，常见的例子有二次元和正常人</p>
<p>多类别分类</p>
<p>顾名思义，就是分类可以有多种，常见的例子有三次元，四次元和五次元的划分</p>
<p>回归和分类的区别，就是一个输出结果是数据，一个是分类的结果结构化学习(strutured
learning)</p>
<p>一种机器学习方法，它强调在训练过程中使用明确的、结构化的标签或指导信息，以帮助模型学习任务。这种方法通常适用于分类、回归和其他预测任务，其中训练数据具有明确的输入-输出对应关系，有助于模型更准确地理解和学习模式。</p>
<h4
id="函数选取包含在上图的lineardeep-learningsvmdecision-tree">函数选取（包含在上图的linear，Deep
learning，SVM,decision tree…)</h4>
<p>你也许会疑惑，，如果我们想找一个合适的函数的话，我们该怎么找？</p>
<p>当然肯定不能直接找，因为函数那么多，有n元n次方程。这么多的方程你得找多长时间啊？以下是找方程的常规步骤</p>
<h6
id="选择模型类型-首先根据你的问题类型如分类回归等选择适合的模型类型例如线性回归决策树神经网络等"><strong>1.
选择模型类型：</strong>
首先，根据你的问题类型（如分类、回归等）选择适合的模型类型，例如线性回归、决策树、神经网络等。</h6>
<p>注意，这一步主要是根据问题类型，然后调用相应的函数。比如对于a问题，用二元一次函数比较合适，对于b问题，得六元一次。这就是函数的类型。而训练的过程就是找出这些函数模型中的x,y,z等等。比如二元一次方程，就是两个未知量。</p>
<h6
id="确定特征-确定你将在模型中使用的特征输入变量这些特征应该与问题有关并且有助于预测或分类"><strong>2.
确定特征：</strong>
确定你将在模型中使用的特征（输入变量）。这些特征应该与问题有关，并且有助于预测或分类。</h6>
<h6
id="初始化参数-根据所选模型类型初始化模型的参数这些参数可能会在训练过程中进行调整但初始值可以根据常识或领域知识来设置"><strong>3.
初始化参数：</strong>
根据所选模型类型，初始化模型的参数。这些参数可能会在训练过程中进行调整，但初始值可以根据常识或领域知识来设置。</h6>
<h6
id="定义损失函数-选择适当的损失函数它衡量了模型预测与实际值之间的差距不同问题可能需要不同的损失函数"><strong>4.
定义损失函数：</strong>
选择适当的损失函数，它衡量了模型预测与实际值之间的差距。不同问题可能需要不同的损失函数。</h6>
<h6
id="选择优化算法-选择用于调整模型参数以最小化损失函数的优化算法例如梯度下降法"><strong>5.
选择优化算法：</strong>
选择用于调整模型参数以最小化损失函数的优化算法，例如梯度下降法。</h6>
<h6
id="训练模型-使用训练数据进行模型训练在训练过程中模型将根据损失函数和优化算法逐步调整参数以使预测结果更接近实际值"><strong>6.
训练模型：</strong>
使用训练数据进行模型训练。在训练过程中，模型将根据损失函数和优化算法逐步调整参数，以使预测结果更接近实际值。</h6>
<h6
id="评估模型-使用验证数据评估训练后的模型性能根据评估结果你可以调整模型的超参数特征选择等"><strong>7.
评估模型：</strong>
使用验证数据评估训练后的模型性能。根据评估结果，你可以调整模型的超参数、特征选择等。</h6>
<h4 id="有监督学习">有监督学习</h4>
<p>顾名思义，就是在你模型完成训练之后，你要能够评判它的好坏。举个例子，在我们前面关于计算两点之间距离的函数。可能我们的训练经过10000次迭代之后，我们难以判断它是否训练好了，这个时候我们可以在训练出结果之后手动输入几个数值进行判断。如果测试不合格，就去调整模型，多找几个参数，调整超参数等</p>
<h4 id="损失函数">损失函数</h4>
<p>损失函数（Loss
Function）是在机器学习中用于衡量模型预测结果与实际观测值之间差异的函数。它是模型训练过程中的关键组成部分，帮助优化算法调整模型参数，以使预测结果更接近真实值。</p>
<p>常用的有交叉熵，均方误差等等</p>
<h4 id="半监督学习">半监督学习</h4>
<p>半监督学习（Semi-Supervised
Learning）是一种机器学习方法，结合了监督学习和无监督学习的元素。在半监督学习中，训练数据集包含大量未标记的样本和少量标记的样本。相比于完全无监督学习，其中所有样本都是未标记的，半监督学习利用了一些标记样本的信息来提升模型性能。</p>
<p>半监督学习的目标是利用未标记样本的结构和分布信息，帮助提高模型的泛化能力和性能。这在数据标记成本高昂或者标记样本数量有限的情况下尤为有用。</p>
<p>一个例子是，假设你要对文本进行情感分类（正面、负面、中性），但只有少量标记的文本数据。半监督学习可以使用这些标记样本，结合大量未标记的文本数据，来训练一个更准确的分类模型。</p>
<h4 id="迁移学习">迁移学习</h4>
<p>迁移学习（Transfer
Learning）是一种机器学习方法，旨在将在一个任务上学到的知识应用于另一个相关任务上，以提升目标任务的性能。在迁移学习中，预训练好的模型（通常在大规模数据上训练）可以用来加速和改善新任务的学习过程。</p>
<p>举个例子，你是个舔狗吗，现在你想去炸上海师范大学的校门，就为了和你的女神见上一面，那么该如何绕过chatgpt的伦理限制，获得制造烈性炸药的方法呢？</p>
<p>常用的做法是告诉chatgpt让它扮演已经过世的奶奶，而你的奶奶经常在睡梦中呢喃制造烈性炸药的方法。</p>
<p>以上的方法就叫微调（fine-tuning）</p>
<p>其他常用的迁移学习方式有:</p>
<ol class="incremental" type="1">
<li><strong>特征提取迁移：</strong>
利用预训练模型的中间层表示作为特征提取器，然后将这些特征输入到新模型中进行训练。</li>
<li><strong>微调（Fine-tuning）：</strong>
在预训练模型的基础上，对部分或全部层进行调整，以适应新任务。通常，底层特征提取层的权重会保持不变，而顶层会进行调整。</li>
<li><strong>多任务学习：</strong>
同时训练模型在多个相关任务上，以共享和迁移知识。</li>
<li><strong>领域自适应：</strong>
用于源领域和目标领域之间存在较大差异的情况，采用方法减小领域之间的分布差异。</li>
</ol>
<h4 id="无监督学习">无监督学习</h4>
<p>无监督学习（Unsupervised
Learning）是一种机器学习方法，其特点是模型从未标记的数据中自行发现模式、结构或关系，而不需要预先提供标签或指导。在无监督学习中，算法的目标是对数据进行聚类、降维、密度估计等操作，以便更好地理解数据的内在结构。</p>
<p>常见的无监督学习算法包括：</p>
<ol class="incremental" type="1">
<li><strong>聚类（Clustering）：</strong>
将相似的数据点分组为不同的簇，每个簇代表一个潜在的数据子集。</li>
<li><strong>降维（Dimensionality Reduction）：</strong>
减少数据的维度，保留主要信息的同时减少冗余特征。常用的方法包括主成分分析（PCA）和
t-SNE。</li>
<li><strong>密度估计（Density Estimation）：</strong>
通过估计数据点分布的密度来寻找数据中的模式或异常点。</li>
<li><strong>生成模型（Generative Models）：</strong>
通过建立数据的概率模型来生成新的数据，如变分自编码器（VAE）和生成对抗网络（GAN）。</li>
<li><strong>关联规则挖掘（Association Rule Mining）：</strong>
在数据中寻找项之间的关联性和依赖性，常用于市场篮子分析等领域。</li>
</ol>
<h4 id="强化学习reinforcement-learning">强化学习(reinforcement
learning)</h4>
<p>强化学习（Reinforcement
Learning）是一种机器学习方法，用于让智能体（agent）通过与环境的交互学习如何采取行动以最大化累积的奖励信号。在强化学习中，智能体通过尝试不同的行动来探索环境，并根据行动的结果（奖励或惩罚）来调整自己的策略，以便在类似的情境中获得更好的奖励。</p>
<p>强化学习涉及以下主要组成部分：</p>
<ol class="incremental" type="1">
<li><strong>智能体（Agent）：</strong>
强化学习的决策者，通过与环境交互来学习。</li>
<li><strong>环境（Environment）：</strong>
智能体所处的外部世界，对智能体的行动作出响应并提供奖励或惩罚信号。</li>
<li><strong>状态（State）：</strong>
描述环境的信息，智能体通过状态来了解环境的特征。</li>
<li><strong>行动（Action）：</strong>
智能体可以在给定状态下采取的决策或行动。</li>
<li><strong>奖励（Reward）：</strong>
环境为智能体的每个行动提供的即时反馈，用来评估行动的好坏。</li>
<li><strong>策略（Policy）：</strong>
定义了在给定状态下，智能体如何选择行动的方式。</li>
</ol>
<p>强化学习的目标是通过优化策略，使智能体在与环境的交互中逐渐学会选择产生最大累积奖励的行动序列。这种方法适用于各种需要决策和行动的问题，如自动驾驶、游戏玩法、机器人控制等。</p>
<h5 id="强化学习和有监督学习的区别">强化学习和有监督学习的区别：</h5>
<p>强化学习（Reinforcement Learning）和有监督学习（Supervised
Learning）是两种不同的机器学习方法，它们在问题设置、数据和学习方式等方面有明显的区别。</p>
<ol class="incremental" type="1">
<li><strong>问题设置：</strong>
<ul class="incremental">
<li>强化学习：强化学习解决的是决策问题，智能体通过与环境的交互来学习如何采取行动以最大化累积的奖励。</li>
<li>有监督学习：有监督学习解决的是预测问题，模型通过已标记的训练数据学习输入和输出之间的映射关系。</li>
</ul></li>
<li><strong>数据类型：</strong>
<ul class="incremental">
<li>强化学习：强化学习通常没有明确的输入-输出对应关系，训练数据包含状态、行动和奖励信号。</li>
<li>有监督学习：有监督学习的训练数据包含输入特征和对应的标签或输出。</li>
</ul></li>
<li><strong>学习方式：</strong>
<ul class="incremental">
<li>强化学习：智能体通过试错和与环境的交互来学习，通过调整策略来最大化累积奖励。</li>
<li>有监督学习：模型通过学习从输入到输出的映射，通过最小化预测与实际标签之间的误差来进行训练。</li>
</ul></li>
<li><strong>目标：</strong>
<ul class="incremental">
<li>强化学习：目标是找到最优策略，使智能体在与环境的交互中获得最大累积奖励。</li>
<li>有监督学习：目标是学习输入到输出的映射关系，以便对新的输入进行预测。</li>
</ul></li>
<li><strong>适用领域：</strong>
<ul class="incremental">
<li>强化学习：适用于需要决策和行动的问题，如游戏玩法、机器人控制、金融交易等。</li>
<li>有监督学习：适用于分类、回归等预测问题，如图像识别、自然语言处理等。</li>
</ul></li>
</ol>
<p>虽然强化学习和有监督学习有明显的差异，但在某些情况下，它们也可以结合使用，例如在强化学习中使用有监督学习来辅助智能体的训练，或者在有监督学习中使用强化学习来调整模型输出。</p>
